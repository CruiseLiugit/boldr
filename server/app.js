import { resolve as pathResolve } from 'path';
import express from 'express';
import appRootDir from 'app-root-dir';
import PrettyError from 'pretty-error';
import getConfig from '../config/get';
import logger from './services/logger';
import redisClient from './services/redis';
import { NotFound } from './core/errors';
import expressMiddleware from './middleware/express';
import authMiddleware from './middleware/auth';
import offlinePage from './middleware/offlinePage';
import serviceWorker from './middleware/serviceWorker';
import rbac from './middleware/rbac';
import routes from './routes/index';
import boldrSSR from './middleware/boldrSSR';
import clientBundle from './middleware/clientBundle';

const cache = require('express-redis-cache')({
  client: redisClient,
});

const app = express();

// contains body-parser, method-override, etc...
expressMiddleware(app);

// contains cookie-parser, passport, jwt, session
authMiddleware(app);
app.use(rbac());
// attaches to router
app.use('/api/v1', routes);

// Register our service worker which was generated by the offline-plugin
// webpack plugin. See the webpack plugins section for more information.
// Note: the service worker needs to be served from the http root of your
// application for it to work correctly.
// We only want the service worker registered for production builds and if
// the config enables it.
if (process.env.NODE_ENV !== 'development' && getConfig('serviceWorker.enabled')) {
  app.get(`/${getConfig('serviceWorker.fileName')}`, serviceWorker);
  app.get(
    `${getConfig('bundles.client.webPath')}${getConfig('serviceWorker.offlinePageFileName')}`,
    offlinePage,
  );
}

app.use(getConfig('bundles.client.webPath'), clientBundle);

// Configure static serving of our "public" root http path static files.
// Note: these will be served off the root (i.e. '/') of our application.
app.use(express.static(pathResolve(appRootDir.get(), getConfig('publicAssetsPath'))));

// The React application middleware.
// cache.route(), we'll add this back later.
app.get('*', boldrSSR);

const pe = new PrettyError();
pe.skipNodeFiles();
pe.skipPackage('express');

// catch 404 and forward response to errorhandler
/* istanbul ignore next */
app.use((err, req, res, next) => {
  process.stderr.write(pe.render(err));
  next();
});

process.on('unhandledRejection', (reason, p) => {
  logger.error('Possibly Unhandled Rejection at: Promise ', p, ' reason: ', reason);
});

export default app;
